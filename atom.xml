<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>留白</title>
  <icon>https://www.gravatar.com/avatar/93bf00b8463a08dd9da1a4db37d17448</icon>
  <subtitle>留白</subtitle>
  <link href="https://www.liubai-icu.top/atom.xml" rel="self"/>
  
  <link href="https://www.liubai-icu.top/"/>
  <updated>2021-09-24T16:00:00.000Z</updated>
  <id>https://www.liubai-icu.top/</id>
  
  <author>
    <name>留白</name>
    <email>3504448058@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>神游万里</title>
    <link href="https://www.liubai-icu.top/2021/09/25/%E7%A5%9E%E6%B8%B8%E4%B8%87%E9%87%8C/"/>
    <id>https://www.liubai-icu.top/2021/09/25/%E7%A5%9E%E6%B8%B8%E4%B8%87%E9%87%8C/</id>
    <published>2021-09-24T16:00:00.000Z</published>
    <updated>2021-09-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><ul><li>最近产生了厌学的情绪，所以已经好多天没有更新过这个博客了。其实也多多少少学了一些知识，但有点繁琐，自己本身也没有搞很明白。</li></ul><p>这篇博客正如标题那样，没有明确的主题，也不会刻意注意排版，完全是我今天出去散步一小时的所思所想。会很无厘头，也可能根本没有意义，看过就看过吧。</p><p>本来是出去跑步的，但是跑了大约只有不到0.5公里吧。没有办法，大学已经不像初高中那样会有早操啊，课间操啊什么的，运动量太少了，本人又是不喜欢运动的，自然而然就剩下现在这水平了。</p><p>走在路上，想着我的身体以后会怎么样，毕竟我现在这小身板啥也不是。还是多走走吧，散步也算锻炼吧！？</p><p>我是不是也该去在网上找一门呼吸法门，这样我跑步就不会气喘吁吁了。</p><p>那些个穿着JK短裙的女生的腿可真漂亮啊，好白啊！自己这样偷瞄，她看到了会不会认为我是色狼啊，心里还是挺心虚的。可是真的好看啊！想着以后还是要多出来走走的，毕竟有好多好看的美女啊。</p><p>现在好多女生穿着还是很暴露的，这样到底是为了美还是为了什么呢！？她们会不会想到其实会被很多男生看到不该看到的呢？</p><p>也有穿着保守的，长的休闲牛仔裤，长袖外套，我像这种的应该大部分会很单纯文静吧。</p><p>还有一些穿着很接地气的，没有一点化妆的痕迹，其实一看就是偏远地方的乡村来的。对于这种我是很感到亲切的，无论男生女生，可能因为是经历相似吧！</p><p>我在想，不论美丑，不论穿着，不论来历，每一个人都是可爱的人。无论人性本善还是本恶，大概是不能仅凭所见的一件事情就评定ta的善恶的。</p><p>我在想，其实每个人都该需要自己一个人待会的，想一想最近做了什么，想一想最近看了什么，想一想之前的遗憾，想想思念的人，想想过往，想想自己到底是什么样的一个人？</p><p>来到操场，这里有很多的人，走了两圈。</p><p>看到好多对情侣也在操场上一起散步。</p><p>他们有说有笑，我就在想，他们是如何认识的呢，是男的先加的男的还是男的先加的女的呢，是男的先表白还是女的追的男的，或者只是自然而然就在一起了呢？女的很好看，是因为画了妆？如果卸了妆很难看，男生还会喜欢她吗？男生不是很帅的样子，女生为什么会喜欢他呢？要是男生只是在她面前表现的很好，其实是很坏的人，那这男生算不算真的喜欢，会不会被知道真相的视为贪图美色？他们聊的很开心，是在聊什么呢，这样绕着操场散步，又说又笑，大概也算浪漫吧？如果是我，大概是紧张的不知道说什么吧，自己还真是一个无趣的人啊？要不要到网上去学习一下怎么准确表达自己的爱意，怎么不显得幼稚，怎么能够夸夸而谈呢？</p><p>还是自己一个人好啊，不用想那么多，也不用刻意讨好谁，也不用说话。如果能和喜欢的人静静的走，也不用说话，大概也算一种浪漫吧？</p><p>坐在观众台。</p><p>看着操场上的众多人，还真是每个人都不同啊。可一想到我自己应该算一个怎样的人，想了半天大概该归为怪人一类吧。实在是连我自己都觉的我自己是一个矛盾的人。</p><p>想到这社会其实是不太公平的，城市的人和农村的人之间是有差距的，富人和穷人之间是有差距的。人与人之间有太多的不同，但一想到若是每个人经历的都一模一样，那这世间又有什么意思。但人与人之间的不能相互理解还是很让我揪心的。</p><p>想到我明知自己没有害人之心，一个老好人而已，相处的好的朋友自然是知道的，但是别人又不知道的，自然又可以把我归为坏人一类。</p><p>那么我以前所谓的坏的人和坏的事，其实并非所见。那我就因那么一件不和的事就认为他是一个坏的人，是不是对他而言很不公平呢？</p><p>那些能说会道的能有几人做了实事，那些默默做着事情的又有几人能得到敬重。那些凭着光鲜外表的明星人人只是唱唱跳跳便赚了名利，那些做着科研的又能有几人活着就被认识和记住？这个世界大概是一直亏欠着好人的。</p><p>或许老秀才的顺序之说最好的评判一个人好坏善恶的吧？但总没有人能够真切的去经历当时人的人生吧？</p><p>若是每个人都可以像齐先生遇到老秀才，陈平安遇到齐先生，裴钱遇到陈平安，那么这世界应该会非常好吧。</p><p>未曾经历，不予评价，无言或许是对一个人最大的善意。</p><p>我想，在君子不救之后应该再加一句，君子不言。</p><p>可，不言对社会进步是无益的，所以还真是矛盾啊。</p><p>已入秋，夜已凉，风紧扯呼。他人于我有何关系？我于他人又有何关系？</p><p>君子先为己。</p><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC81NDI0MS8zMDcxMw=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>二维码基本介绍</title>
    <link href="https://www.liubai-icu.top/2021/09/11/%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.liubai-icu.top/2021/09/11/%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-09-10T16:00:00.000Z</published>
    <updated>2021-09-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h4 id="二维码简介"><a href="#二维码简介" class="headerlink" title="二维码简介"></a>二维码简介</h4><p>二维码又称QR  Code，QR的全称是：Quick Response，相比于Bar Code（即：条形码）能存储更多的信息，也能表示更多的数据类型，字符、数字、中文和日文等。</p><h4 id="基础认识"><a href="#基础认识" class="headerlink" title="基础认识"></a>基础认识</h4><h5 id="版本分类"><a href="#版本分类" class="headerlink" title="版本分类"></a>版本分类</h5><p>二维码总共分40个尺寸，官方称为版本（Version）。其中 Version1 是一个 21 * 21 的矩阵。Version2 是一个 25 * 25的矩阵。其实每增加一个Version，矩阵的尺寸大小就会增加4。从而得到版本的尺寸计算方法为：（V-1）* 4 + 21。</p><h5 id="二维码的样例及各个部位的介绍"><a href="#二维码的样例及各个部位的介绍" class="headerlink" title="二维码的样例及各个部位的介绍"></a>二维码的样例及各个部位的介绍</h5><p>下面先展示一个二维码的样例图：</p><p><img src="https://ldk_code.gitee.io/liubai/img/postImg/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%BB%84%E6%88%90%E7%A4%BA%E4%BE%8B.jpg" alt="样例图"></p><h5 id="各部分介绍"><a href="#各部分介绍" class="headerlink" title="各部分介绍"></a>各部分介绍</h5><p><strong>定位图案</strong></p><ul><li><code>Position Detection Pattern</code>：用于标记二维码的矩形大小。这三个定位图案有白边叫<code>Sparators for Position Detection Patterns</code>。之所以是三个而不是四个的原因是三个就可以标识一个矩形了。</li><li><code>Timing Patterns</code>：也是用于定位的。原因是二维码有40种尺寸，尺寸过大了后需要有根标准线，不然的话扫描的时候可能扫歪。</li><li><code>Alignment Patterns</code>：只有Version2以上（包括Version2）的二维码需要这个，作用同样是为了定位</li></ul><p><strong>功能性数据</strong></p><ul><li><code>Format Information</code>：存在于所有版本中，作用是存放一些格式化数据的。</li><li><code>Version Information</code>：Version7（包括Version7）以上，需要预留两块3 * 6的区域存放一些版本信息。</li></ul><p><strong>数据码和纠错码</strong></p><ul><li>除了上述的那些地方，剩下的地方存放<code>Data Code</code>（数据码）和<code>Error Correction Code</code>（纠错码）。</li></ul><h4 id="编码过程简单介绍"><a href="#编码过程简单介绍" class="headerlink" title="编码过程简单介绍"></a>编码过程简单介绍</h4><h5 id="数据编码"><a href="#数据编码" class="headerlink" title="数据编码"></a>数据编码</h5><p>QR Code支持下面的编码方式</p><ul><li><code>Numeric mode</code>：数字编码，范围是0~9。如果编码的数字的位数不是3的倍数，那么最后剩下的1或2位数字会被转成4或7 bits。其它的每3位数字会被编成10，12，或14 bits，编码的长度取决于二维码的尺寸。</li><li><code>Alphanumeric mode</code>：字符编码，范围：0<del>9，大写的A</del>Z（没有小写），以及符号<code>$ % * + - . /</code>包括空格。这些字符会映射成一个字符索引表。如下图所示：</li></ul><table><thead><tr><th align="center">char</th><th align="center">value</th><th align="center">char</th><th align="center">value</th><th align="center">char</th><th align="center">value</th><th align="center">char</th><th align="center">value</th><th align="center">char</th><th align="center">value</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">9</td><td align="center">9</td><td align="center">I</td><td align="center">18</td><td align="center">R</td><td align="center">27</td><td align="center">SP</td><td align="center">36</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">A</td><td align="center">10</td><td align="center">J</td><td align="center">19</td><td align="center">S</td><td align="center">28</td><td align="center">$</td><td align="center">37</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">B</td><td align="center">11</td><td align="center">K</td><td align="center">20</td><td align="center">T</td><td align="center">29</td><td align="center">%</td><td align="center">38</td></tr><tr><td align="center">3</td><td align="center">3</td><td align="center">C</td><td align="center">12</td><td align="center">L</td><td align="center">21</td><td align="center">U</td><td align="center">30</td><td align="center">*</td><td align="center">39</td></tr><tr><td align="center">4</td><td align="center">4</td><td align="center">D</td><td align="center">13</td><td align="center">M</td><td align="center">22</td><td align="center">V</td><td align="center">31</td><td align="center">+</td><td align="center">40</td></tr><tr><td align="center">5</td><td align="center">5</td><td align="center">E</td><td align="center">14</td><td align="center">N</td><td align="center">23</td><td align="center">W</td><td align="center">32</td><td align="center">-</td><td align="center">41</td></tr><tr><td align="center">6</td><td align="center">6</td><td align="center">F</td><td align="center">15</td><td align="center">O</td><td align="center">24</td><td align="center">X</td><td align="center">33</td><td align="center">.</td><td align="center">42</td></tr><tr><td align="center">7</td><td align="center">7</td><td align="center">G</td><td align="center">16</td><td align="center">P</td><td align="center">25</td><td align="center">Y</td><td align="center">34</td><td align="center">/</td><td align="center">43</td></tr><tr><td align="center">8</td><td align="center">8</td><td align="center">H</td><td align="center">17</td><td align="center">Q</td><td align="center">26</td><td align="center">Z</td><td align="center">35</td><td align="center">:</td><td align="center">44</td></tr></tbody></table><p>（其中的SP表示的空格，char表示的是字符，value表示的是对应字符的索引值。）</p><p>编码的过程是先把字符两辆分组，然后转成上面表中的45进制，再转成11 bits的二进制，如果最后有一个落单的，那就转成6 bits的二进制。而编码模式和字符的个数需要根据不同的Version尺寸编成9，11或13 bits二进制。</p><ul><li><p><code>Byte mode</code>：字节编码，可以是0~255的ISO-8859-1字符。有些二维码的扫描器可以自动检测是否是    UTF-8的编码。</p></li><li><p><code>Kanji mode</code>：这是日文编码，他也是双字节编码。同样，也可以用于中文编码。</p></li><li><p><code>Extended Channel Interpretation(ECI) mode</code>：主要用于特殊的字符集。并不是所有的扫描器都支持这种编码。</p></li><li><p><code>Structured Append mode</code>： 用于混合编码，也就是说，这个二维码中包含了多种编码格式。</p></li><li><p><code>FNC1 mode</code>： 这种编码方式主要是给一些特殊的工业或行业用的。比如GS1条形码之类的。</p></li></ul><p>简单起见，后面三种不会在本文 中讨论。</p><p><img src="http://coolshell.cn//wp-content/uploads/2013/10/Mode-Indicator.png" alt="编码规范"></p><ul><li>Table 2表示各种编码格式的编号，要写在Format Information中。注意：中文的编号为：1101</li><li>Table 3表示的是对不同Version中编码格式的规范。</li></ul><h5 id="结束符和补齐符"><a href="#结束符和补齐符" class="headerlink" title="结束符和补齐符"></a>结束符和补齐符</h5><p>假如我们有个HELLO WORLD的字符串要编码，我们可以得到下面的编码：</p><table><thead><tr><th align="left">编码</th><th align="left">字符数</th><th align="left">HELLO WORLD的编码</th></tr></thead><tbody><tr><td align="left">0010</td><td align="left">000001011</td><td align="left">01100001011 01111000110 10001011100 10110111000 10011010100 001101</td></tr></tbody></table><p>我们还要加上结束符：</p><table><thead><tr><th align="left">编码</th><th align="left">字符数</th><th align="left">HELLO WORLD的编码</th><th align="left">结束</th></tr></thead><tbody><tr><td align="left">0010</td><td align="left">000001011</td><td align="left">01100001011 01111000110 10001011100 10110111000 10011010100 001101</td><td align="left">0000</td></tr></tbody></table><p><strong>按8bits重排</strong></p><p>如果所有的编码加起来不是8个倍数我们还要在后面加上足够的0，比如上面一共有78个bits，所以，我们还要加上2个0，然后按8个bits分好组：</p><p>00100000  01011011  00001011  01111000  11010001  01110010  11011100  01001101  01000011  010000<strong>00</strong></p><p><strong>补齐码（Padding Bytes）</strong></p><p>最后，如果如果还没有达到我们最大的bits数的限制，我们还要加一些补齐码（Padding Bytes），Padding Bytes就是重复下面的两个 bytes ：11101100 00010001 （这两个二进制转成十进制是236和17，我也不知道为什么，只知道Spec上是这么写的）关于每一个Version的每一种纠错级别的最大Bits限制，可以参看<a href="https://www.hkma.gov.hk/media/eng/doc/key-functions/finanical-infrastructure/infrastructure/retail-payment-initiatives/Common_QR_Code_Specification.pdf">QR Code Specification</a>的第28页到32页的Table-7一表。</p><p>假设我们需要编码的是Version 1的Q纠错级，那么，其最大需要104个bits，而我们上面只有80个bits，所以，还需要补24个bits，也就是需要3个Padding Bytes，我们就添加三个，于是得到下面的编码：</p><p>00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 01000000 <strong>11101100 00010001 11101100</strong></p><p>上面的编码就是数据码了，叫Data Codewords，每一个8bits叫一个codeword，我们还要对这些数据码加上纠错信息。</p><h5 id="纠错码"><a href="#纠错码" class="headerlink" title="纠错码"></a>纠错码</h5><p>上面我们说到了一些纠错级别，Error Correction Code Level，二维码中有四种级别的纠错，这就是为什么二维码有残缺还能扫出来，也就是为什么有人在二维码的中心位置加入图标。</p><table><thead><tr><th align="left">错误修正容量</th><th></th></tr></thead><tbody><tr><td align="left">L水平</td><td>7%的字码可被修正</td></tr><tr><td align="left">M水平</td><td>15%的字码可被修正</td></tr><tr><td align="left">Q水平</td><td>25%的字码可被修正</td></tr><tr><td align="left">H水平</td><td>30%的字码可被修正</td></tr></tbody></table><p><a href="https://blog.csdn.net/hk_5788/article/details/50839790">文章转载地在此</a></p><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC81NDI0MS8zMDcxMw=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
    <category term="项目" scheme="https://www.liubai-icu.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>方法可变参数</title>
    <link href="https://www.liubai-icu.top/2021/09/07/%E6%96%B9%E6%B3%95%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"/>
    <id>https://www.liubai-icu.top/2021/09/07/%E6%96%B9%E6%B3%95%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</id>
    <published>2021-09-06T16:00:00.000Z</published>
    <updated>2021-09-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h3 id="方法可变参数"><a href="#方法可变参数" class="headerlink" title="方法可变参数"></a>方法可变参数</h3><p>什么是可变参数？简单来说就是再给方法传参数的时候可以传入未知个参数。</p><p>下面通过代码例子具体体验一下这个特性。</p><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nums</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ... data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> temp:data)&#123;</span><br><span class="line">            sum+=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">   System.out.println(Nums.sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：可变参数的本质还是数组。</p><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC81NDI0MS8zMDcxMw=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
    <category term="java基础" scheme="https://www.liubai-icu.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>约瑟夫环的问题</title>
    <link href="https://www.liubai-icu.top/2021/09/06/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://www.liubai-icu.top/2021/09/06/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-09-05T16:00:00.000Z</published>
    <updated>2021-09-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h3 id="约瑟夫环的问题"><a href="#约瑟夫环的问题" class="headerlink" title="约瑟夫环的问题"></a>约瑟夫环的问题</h3><p>在初级算法的学习过程下，数组中的一个旋转数组的问题上，有用到约瑟夫环的思想，但是当时并不知道思想为约瑟夫环，特意查了并做一下记录。</p><h4 id="什么是约瑟夫环？"><a href="#什么是约瑟夫环？" class="headerlink" title="什么是约瑟夫环？"></a>什么是约瑟夫环？</h4><p>约瑟夫环（约瑟夫问题）是一个数学的应用问题：已知 n 个人（以编号1，2，3…n分别表示）围坐在一张圆桌周围。从编号为 k 的人开始报数，数到 m 的那个人出圈；他的下一个人又从 1 开始报数，数到 m 的那个人又出圈；依此规律重复下去，直到剩余最后一个胜利者。</p><h4 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h4><p>模拟真实的游戏过程，是创建一个单循环链表。</p><p>具体实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">note</span>&#123;</span><span class="comment">//自定义的节点数据类型</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">note</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;note,*Note;</span><br><span class="line"></span><br><span class="line"><span class="function">Note <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//使用的是尾插法创建的，单循环链表创建</span></span><br><span class="line">Note head=(Note) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(note));</span><br><span class="line">Note newHead=head;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">newHead-&gt;data=i;</span><br><span class="line">newHead-&gt;next=(Note) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(note));</span><br><span class="line"><span class="keyword">if</span>(i!=n) newHead=newHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">newHead-&gt;next=head;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">10</span>,m=<span class="number">3</span>;<span class="comment">//为了方便自己提前确定了数据</span></span><br><span class="line">Note head=init(n);</span><br><span class="line">Note temp=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(head-&gt;next!=head)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">temp=head;</span><br><span class="line">head=head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,head-&gt;data);</span><br><span class="line">temp-&gt;next=head-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(head);</span><br><span class="line">head=temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nfinal: %d&quot;</span>,head-&gt;data);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照上面的程序：<br>第一层循环<code>while</code>循环会执行<code>n-1</code>次，第二层循环<code>for</code>会执行<code>m-1</code>次，所以可以计算时间复杂度为<code>O(n*m)</code>。</p><p>这样的话若是n和m的数值都很大的时候，那没短时间内是很难得到结果的。</p><p>有没有更简单的实现，以便在特定情况下缩短时间。当然是有的。</p><h4 id="利用数学解法进行优化"><a href="#利用数学解法进行优化" class="headerlink" title="利用数学解法进行优化"></a>利用数学解法进行优化</h4><p>提前声明：该方法适用于直接找到胜利者的坐标，要想知道具体的过程还是需要上面的模拟过程的。</p><p>先放出结论公式：<code>f(n,m)=(f(n-1,m)+m)%n;</code></p><p>公式解释：</p><ul><li><code>f(n,m)</code>表示，n个人报数，每报到m时淘汰那个人，结果为最终胜利者的坐标。</li></ul><p>规律查找：（以下都以m=3为例）</p><ul><li>n=1，f（1，3）=0；</li><li>n=2，f（2，3）=（f（1，3）+3）%2=1；</li><li>n=3，f（3，3）=（f（2，3）+3）%3=1；</li><li>。。。</li><li>f（n，m）=（f（n-1，m）+m）%n；</li></ul><p>根据上面的规律可以得出以下代码：（只是一个函数）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Joseph_ring</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> winPotion=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        win=(win+m)%n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> winPotion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出，上面的函数的时间复杂度仅为O(n)。</p><p>详细的规律推导请参考<a href="https://www.jianshu.com/p/e2c69573faa7">链接</a>。</p><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC81NDI0MS8zMDcxMw=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
    <category term="算法" scheme="https://www.liubai-icu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>代码块</title>
    <link href="https://www.liubai-icu.top/2021/08/24/%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    <id>https://www.liubai-icu.top/2021/08/24/%E4%BB%A3%E7%A0%81%E5%9D%97/</id>
    <published>2021-08-23T16:00:00.000Z</published>
    <updated>2021-08-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>在程序之中使用“{}”定义的结构就称为代码块，而后根据代码块出现的位置以及定义的关键字的不同，代码块可以分为：普通代码块、构造块、静态块、同步代码块，其中对于同步代码是在多线程的时候才进行讲解。</p><h4 id="普通代码块"><a href="#普通代码块" class="headerlink" title="普通代码块"></a>普通代码块</h4><p>普通代码块的主要特点是定义在一个方法之中的代码块。</p><p>范例：观察以下代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Strig [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=<span class="number">10</span>;<span class="comment">//局部变量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;x=&quot;</span>+x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">100</span>;<span class="comment">//相对于上面，为全局变量（相对概念）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;x=&quot;</span>+x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照Java程序的规定相同名称的变量是不能够在同一个方法之中存在的，但是有由于此时有不同的分界的描述。</p><p>而如果说要定义普通代码块，那么只需将当前的if语句取消即可。即上面的代码改成下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Strig [] args)</span></span>&#123;</span><br><span class="line">        &#123;<span class="comment">//普通代码块</span></span><br><span class="line">            <span class="keyword">int</span> x=<span class="number">10</span>;<span class="comment">//局部变量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;x=&quot;</span>+x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">100</span>;<span class="comment">//相对于上面，为全局变量（相对概念）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;x=&quot;</span>+x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通代码可以在一个方法中进行一些结构的拆分，以防止相同变量名称所带来的相互影响。</p><h4 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h4><p>构造块是定义在一个类之中的。</p><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【构造方法】构造方法正在执行。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【构造块】构造块正在执行。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  【构造块】构造块正在执行。。。</span></span><br><span class="line"><span class="comment">  【构造方法】构造方法正在执行。。。</span></span><br><span class="line"><span class="comment">  【构造块】构造块正在执行。。。</span></span><br><span class="line"><span class="comment">  【构造方法】构造方法正在执行。。。</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><p>由上面的执行结果可以看出，构造块会优先于构造方法执行，并且每一次实例化新对象的时候都会调用构造块中的代码。</p><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p>静态代码块主要是指使用static关键字定义的代码块，静态块的定义需要考虑到两种情况：主类中定义静态块、非主类中定义静态块。</p><p>范例：在非主类中定义静态代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【构造方法】构造方法正在执行。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【静态块】静态代码正在执行中。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【构造块】构造块正在执行。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">【静态块】静态代码正在执行中。。。</span></span><br><span class="line"><span class="comment">【构造块】构造块正在执行。。。</span></span><br><span class="line"><span class="comment">【构造方法】构造方法正在执行。。。</span></span><br><span class="line"><span class="comment">【构造块】构造块正在执行。。。</span></span><br><span class="line"><span class="comment">【构造方法】构造方法正在执行。。。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>有上面的执行结果可以看出：静态块会优先于构造块的执行，并且不管有多少个实例化对象出现静态代码块只会执行一次。</p><p>静态代码块的主要目的是为类中的静态属性初始化。</p><p>举例使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCountry</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;中华人民共和国&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String country;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        country=Message.getCountry();</span><br><span class="line">        System.out.println(country);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="comment">//中华人民共和国</span></span><br></pre></td></tr></table></figure><p>范例：在主类中定义静态代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;***静态代码执行***&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;***主方法执行***&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">***静态代码执行***</span></span><br><span class="line"><span class="comment">***主方法执行***</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>由上面的执行结果可以得到：静态代码块优先于主方法先执行。</p><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC81NDI0MS8zMDcxMw=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
    <category term="java基础" scheme="https://www.liubai-icu.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数组的基础了解</title>
    <link href="https://www.liubai-icu.top/2021/08/24/%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/"/>
    <id>https://www.liubai-icu.top/2021/08/24/%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/</id>
    <published>2021-08-23T16:00:00.000Z</published>
    <updated>2021-08-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h3 id="数组的基础了解"><a href="#数组的基础了解" class="headerlink" title="数组的基础了解"></a>数组的基础了解</h3><p>所有的项目开发之中都一定会存在有数组的使用，基本数组的使用概率是有的，但是不高，并且也不会涉及到过多复杂的操作。</p><h4 id="数组的基本定义"><a href="#数组的基本定义" class="headerlink" title="数组的基本定义"></a>数组的基本定义</h4><p>在Java里面将数组定义为了引用数据类型，所以数组的使用一定会牵扯到内存分配，所以就会想到使用关键字new。</p><p>数组的定义格式：</p><ul><li>数组的动态初始化：初始化之后数组每一个元素的保存内容为其对应数据的默认值；<ul><li>声明并初始化数组：<ul><li><code>数据类型 数组名称 [] = new 数据类型 [长度];</code>（第一种方式）</li><li><code>数据类型 [] 数组名称 = new 数据类型 [长度];</code>（第二种方式）</li></ul></li></ul></li><li>数组的静态初始化：在数组定义的时候就为其设置好了里面的内容；<ul><li>简化格式：<code>数据类型 数组名称 [] =&#123;数据1，数据2，数据3，...&#125;;</code>（[]在前在后都可）</li><li>完整格式：<code>数据类型 数组名称 [] =new 数据类型 [] &#123;数据1，数据2，数3，...&#125;;</code>（建议使用这种格式）</li></ul></li></ul><p>范例：定义一个长度为10的整型数组，名字为data</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [] data = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>注意：数组的角标范围和c语言一样，向上面的10个长度，实际是0~9；如果超出这个范围则会出现“数组越界(Array Index Out Of Bounds Exception)”异常；没有初始化的数组在引用的时候会出现”Null Pointer Exception“异常。</p><ul><li>对于数组的长度也可以使用”<code>数组名称.length</code>“来获得。</li></ul><p>附加英语单词的学习：</p><ul><li>Null 零</li><li>Pointer 指针</li><li>Exception 异常</li></ul><h4 id="数组的引用传递分析"><a href="#数组的引用传递分析" class="headerlink" title="数组的引用传递分析"></a>数组的引用传递分析</h4><p>数组的内存分析与之前的对象实例化的内存分析是一样的，那么既然如此，作为引用数据类型的数组，也可以有多个栈内存指向所开辟的堆内存。那么数组怎么实现呢？</p><p>假设引用上面的data：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [] temp=data;</span><br></pre></td></tr></table></figure><p>这样的话<code>temp</code>也可以使用<code>data</code>数组的数据了。</p><h4 id="foreach迭代输出"><a href="#foreach迭代输出" class="headerlink" title="foreach迭代输出"></a>foreach迭代输出</h4><p>对于数组而言，一般都会使用for循环进行输出，但是在使用传统的for循环输出的时候往往都采用了下标的形式进行数组元素的访问。</p><p>在JDK 1.5之后为了减轻下标对程序的影响（如果下标处理不当则会出现数组越界的异常），所以参考了.NET中的设计，引用了一个增强型的for循环（foreach）。</p><p>利用foreach的语法结构可以直接自动获取数组中的每一个元素，避免下标访问。</p><p>foreach语法：<code>for（数据类型  变量 ：数组名|集合）&#123;&#125;</code>(‘|’是为了表示或的意思，即数组或者一个集合都可)</p><p>它最大的特点在于可以自动将数组中的每一个与元素的内容取出保存在变量里面。</p><p>范例：使用foreach语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] data =<span class="keyword">new</span> <span class="keyword">int</span> [] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> temp:data)&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>二维数组的定义：</p><ul><li>数组的动态初始化：<ul><li><code>数据类型 数组名称 [][]=new 数据类型 [行个数][列个数]；</code></li></ul></li><li>数组的静态初始化：<ul><li><code>数据类型 数组名称 [][]=new 数据类型 [][]&#123;&#123;数据,数据,...&#125;,&#123;数据,..&#125;,&#123;...&#125;,...&#125;</code></li></ul></li></ul><p>使用foreach输出二维数组的范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [][] data =<span class="keyword">new</span> <span class="keyword">int</span> [][] &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> temp[]:data)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num:temp)&#123;</span><br><span class="line">                System.out.print(num+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过foreach可以看出二维数组就是数组的嵌套使用。</p><p>从二维数组出发的思考：既然存在二维数组，那肯定可以有三维、四维等，但是二维数组在开发中已经很少使用了，所以没有必要去了解其他的，超过二维的统称为多维数组。</p><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC81NDI0MS8zMDcxMw=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
    <category term="java基础" scheme="https://www.liubai-icu.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>static关键字</title>
    <link href="https://www.liubai-icu.top/2021/08/23/static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://www.liubai-icu.top/2021/08/23/static%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2021-08-22T16:00:00.000Z</published>
    <updated>2021-08-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>static关键字主要可以用来定义属性和方法。</p><h4 id="声明static属性"><a href="#声明static属性" class="headerlink" title="声明static属性"></a>声明static属性</h4><p>在一个类中，所有的属性一但定义了实际上都交由各自的堆内存空间保存。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String country=<span class="string">&quot;中华民国&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法的话，在生成对象的时候每个对象都会拥有自己的这三个属性。假设现在已经生成了13亿个对象，但是country的值要改变为中华人民共和国。</p><p>传统的做法会很痛苦的，但是把country属性声明为static的话，即公共属性，就可以通过任一对象改变country的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> String country=<span class="string">&quot;中华民国&quot;</span>;<span class="comment">//注意点</span></span><br><span class="line">    <span class="comment">//封装的话是 private static String country=&quot;中华民国&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时country的数据其实是保存在<strong>全局数据区</strong>。</p><p>但是对于static属性的访问需要注意一点：由于本身是一个公共的属性，虽然可以通过对象进行访问，但是最好的做法应该是通过所有对象的最高代表（类）来进行访问，<strong>所以static属性可以由类名称直接调用。</strong></p><ul><li><code>Person.country=&quot;中华人民共和国&quot;;</code></li></ul><p>注意：static属性虽然定义在类之中，但是并不受到类实例化对象的控制。即：<strong>static属性可以在没有实例化对象的时候。</strong></p><h4 id="声明static方法"><a href="#声明static方法" class="headerlink" title="声明static方法"></a>声明static方法</h4><p>static方法的主要特点在于，其可以直接由类名称在没有实例化对象的情况下进行调用。</p><p>范例：定义static方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String country=<span class="string">&quot;中华民国&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCountry</span><span class="params">(String c)</span></span>&#123;</span><br><span class="line">        country=c; <span class="comment">/*注意不能使用this.country,所以参数也不能使用String String country*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其他的setter和getter方法略</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span>+<span class="keyword">this</span>.name+<span class="string">&quot;年龄：&quot;</span>+<span class="keyword">this</span>.age+<span class="string">&quot;国家：&quot;</span>+<span class="keyword">this</span>.country;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        Person.setCountry(<span class="string">&quot;中华人民共和国&quot;</span>);</span><br><span class="line">        Person per=<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(per.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关于static方法的注意点：</strong></p><ul><li><strong>static方法只允许调用static属性或方法；</strong></li><li><strong>非static方法允许调用static属性或方法；</strong></li></ul><p>之所以会有上面注意点出现的情况是因为static定义的属性和方法都可以在没有实例化对象的前提下使用，而所有的非static的属性和方法必须在实例化对象的情况下才可以使用。</p><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC81NDI0MS8zMDcxMw=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
    <category term="java基础" scheme="https://www.liubai-icu.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>简单类</title>
    <link href="https://www.liubai-icu.top/2021/08/22/Java%20%E7%9A%84%E7%AE%80%E5%8D%95%E7%B1%BB/"/>
    <id>https://www.liubai-icu.top/2021/08/22/Java%20%E7%9A%84%E7%AE%80%E5%8D%95%E7%B1%BB/</id>
    <published>2021-08-21T16:00:00.000Z</published>
    <updated>2021-08-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>所谓的简单Java类指的是可以描述某一些信息的程序类，例如：描述一个人、描述一本书等，并且这个类中没有特别复杂的逻辑结构，只作为一种信息存储的媒介存在。</p><p>对于简单Java类而言，其核心的开发结构如下：</p><ul><li>类名称一定要有意义，可以描述某一类事物；</li><li>类中的属性必须使用private进行封装，同时封装后的属性必须要提供有setter、getter方法；</li><li>类中必须保留无参的构造方法；</li><li>类之中不允许出现任何的输出语句，所有的内容必须返回；</li><li>【非必须】提供有一个获取对象详细信息的方法，暂时将此方法名称定义为getInfo（）。</li></ul><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC81NDI0MS8zMDcxMw=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
    <category term="java基础" scheme="https://www.liubai-icu.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>this关键字</title>
    <link href="https://www.liubai-icu.top/2021/08/22/this%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://www.liubai-icu.top/2021/08/22/this%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2021-08-21T16:00:00.000Z</published>
    <updated>2021-08-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>this是Java里面比较复杂的关键字，因为this的使用形式上决定了它的灵活性，在程序里面使用this，可以实现一下三类结构的描述：</p><ul><li>当前类中的属性：<code>this.属性</code>;</li><li>当前类中的方法（构造方法、普通方法）：<code>this()</code>、<code>this.方法名称()</code>;</li><li>描述当前对象；（最头疼的原因就在于此）</li></ul><h5 id="使用this调用本类属性"><a href="#使用this调用本类属性" class="headerlink" title="使用this调用本类属性"></a>使用this调用本类属性</h5><p>目前已知可以利用构造方法或者是setter方法都可以进行类中的属性的赋值，但是再进行方法的定义的时候参数名称总是需要再次命名。</p><p>那么有什么方法可以让参数名称与原名称一样呢？答案是：this；</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+<span class="keyword">this</span>.name+<span class="string">&quot;、年龄：&quot;</span>+<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议以后只要是访问本类中属性的时候，请加上“this”实现访问。</p><h5 id="使用this调用方法"><a href="#使用this调用方法" class="headerlink" title="使用this调用方法"></a>使用this调用方法</h5><p>需要考虑构造方法和普通方法调用的区别：</p><ul><li>构造方法：<code>this()</code>;使用关键字new实例化对象的时候才会调用构造方法；</li><li>普通方法：<code>this.方法名称()</code>;实例化对象产生后就可以调用普通方法。</li></ul><p>普通方法的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setName(name);   <span class="comment">//等同于setName(name);this加与不加是一样的。</span></span><br><span class="line">        <span class="keyword">this</span>.setAge(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;、年龄：&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">&quot;留白&quot;</span>,<span class="number">19</span>).tell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法的示例：有三个构造方法，每个构造方法在被调用的时候都要输出一句，该方法正在被调用。</p><p>传统示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;***该方法正在被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        System.out.println(<span class="string">&quot;***该方法正在被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">        System.out.println(<span class="string">&quot;***该方法正在被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;、年龄：&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">&quot;留白&quot;</span>,<span class="number">19</span>).tell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用this关键字的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;***该方法正在被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;、年龄：&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">&quot;留白&quot;</span>,<span class="number">19</span>).tell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到使用this关键字简化了一些重复的代码；</p><p>但是使用this的时候有以下的几点需要注意：</p><ul><li>构造方法必须在实例化新对象的时候调用，所以”this()“的语句<strong>只允许放在构造方法的首行</strong>。（否则报错：<strong>对this的调用必须是构造器中的第一个语句</strong>）</li><li>构造方法互相调用时请保留有程序的出口，即：防止形成死循环（否则报错：<strong>递归构造器调用</strong>）。</li></ul><h4 id="第三种使用this的方法还没有学习到，之后学习了之后会有更新。。。"><a href="#第三种使用this的方法还没有学习到，之后学习了之后会有更新。。。" class="headerlink" title="第三种使用this的方法还没有学习到，之后学习了之后会有更新。。。"></a>第三种使用this的方法还没有学习到，之后学习了之后会有更新。。。</h4><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC81NDI0MS8zMDcxMw=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
    <category term="java基础" scheme="https://www.liubai-icu.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>深入分析类与对象</title>
    <link href="https://www.liubai-icu.top/2021/08/20/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.liubai-icu.top/2021/08/20/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-08-19T16:00:00.000Z</published>
    <updated>2021-08-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h4 id="深入分析类与对象"><a href="#深入分析类与对象" class="headerlink" title="深入分析类与对象"></a>深入分析类与对象</h4><h5 id="成员属性封装"><a href="#成员属性封装" class="headerlink" title="成员属性封装"></a>成员属性封装</h5><p>在类中的组成就是属性与方法，一般而言方法都是对外提供服务的，所以是不会进行封装处理的，但是属性由于需要较高的安全性，往往需要对其进行保护，这个时候就需要采用封装对属性进行保护。</p><p>可以利用private关键字对属性进行封装处理。而属性一旦封装之后外部就不能直接访问，即：对外部不可见，对类的内部是可见的。</p><p>private的作用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;、年龄：&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        Person per=<span class="keyword">new</span> Person();</span><br><span class="line">        per.name=<span class="string">&quot;留白&quot;</span>;</span><br><span class="line">        per.age=<span class="number">19</span>;</span><br><span class="line">        per.tell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在IDEA中会出现如下错误提示</span></span><br><span class="line"><span class="comment">//java: name 在 Person 中是 private 访问控制</span></span><br></pre></td></tr></table></figure><p>如果要想外部的程序可以访问封装的属性，则在Java开发标准中提供有如下要求：</p><ul><li>【setter、getter】设置或取得属性可以使用setXxx()、getXxx()方法，以<code>private String name</code>为例：<ul><li>设置属性方法：<code>public void setName(String n);</code></li><li>获取属性方法：<code>public String getName();</code></li></ul></li></ul><p>封装属性的程序体验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String N)</span></span>&#123;</span><br><span class="line">        name=N;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> A)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            age=A;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;、年龄：&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        Person per=<span class="keyword">new</span> Person();</span><br><span class="line">        per.setName(<span class="string">&quot;留白&quot;</span>);</span><br><span class="line">        per.setAge(-<span class="number">19</span>);</span><br><span class="line">        per.tell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以后的开发中，类中的所有属性都必须使用private封装，并且属性需要进行访问的时候，必须要提供有：setter、getter方法。</p><h5 id="构造方法与匿名对象"><a href="#构造方法与匿名对象" class="headerlink" title="构造方法与匿名对象"></a>构造方法与匿名对象</h5><p>通过上面的封装方式不难发现如果属性过多的时候，就需要写很多个setter方法，太过于麻烦。所以Java对对象的初始化问题，专门提供有构造方法。即：可以通过构造方法实现实例化对象中的属性初始化处理。</p><p>只有在关键字<strong>new</strong>的时候使用构造方法。</p><p>在Java程序里构造方法的定义要求如下：</p><ul><li>构造方法名称必须与类<strong>名称保持一致</strong>；</li><li>构造方法<strong>不允许设置任何的返回值类型</strong>，即：<strong>没有返回值的定义</strong>；</li><li>构造方法是在使用关键字<strong>new</strong>实例化对象的时候自动调用的。</li></ul><p>范例：定义构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n,<span class="keyword">int</span> a)</span></span>&#123;<span class="comment">//有参构造</span></span><br><span class="line">        name=n;</span><br><span class="line">        age=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;、年龄：&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        Person per=<span class="keyword">new</span> Person(<span class="string">&quot;留白&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        per.tell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话代码也就更加简洁了。</p><p>在Java程序里面考虑到程序的完整性，所以所有的类都会提供构造方法，如果现在你的类中没有定义构造方法，那么一定会默认提供有一个无参的，什么都不做的构造方法，这个构造方法是在程序编译的时候自动创建的。如果你的程序里已经明确的定义了构造方法，那么这个默认的构造方法将不会被自动创建。</p><p>注意：一个类至少存在一个构造方法，永恒存在。</p><p>疑问：为什么构造方法不允许设置返回值类型？</p><p>（既然构造方法不需要返回数据，为什么不使用void呢？）</p><p>分析：程序编译器是根据代码的结构来进行编译处理的，执行的时候也是根据代码的结构来处理的。</p><p>所以当设置了返回数据的类型，那结构就会和普通的方法相同，这样编译器会认为此方法是一个普通的方法。</p><p>构造方法和普通方法的区别：</p><ul><li>构造方法是在对象实例化的时候调用的，而普通方法是在对象实例化之后调用的。</li></ul><p>既然构造方法本事也是一个方法，那么方法旧具有重载的特点，而构造方法在重载的时候只需要考虑参数的类型及个数即可。</p><p>在进行多个构造方法的定义的时候，建议有一些定义的顺序，例如：可以按照参数的个数降序或升序排序。</p><p>经过分析可以发现，构造方法的确可以进行数据的设置，而对于setter也可以进行数据的设置。但一定要清楚，<strong>构造方法是在对象实例化的时候为属性设置初始化内容，而setter除了拥有设置数据的功能外，还具有修改数据的功能</strong>。</p><p>如果只进行了对象的实例化，而没有对象的引用名称，会发生什么呢？<br>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        name=n;</span><br><span class="line">        age=a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;、年龄：&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">&quot;留白&quot;</span>,<span class="number">19</span>).tell();<span class="comment">//注意点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果：</span></span><br><span class="line"><span class="comment">//姓名：留白、年龄：19</span></span><br></pre></td></tr></table></figure><p>这种方式没有对象名字的方式就称为匿名对象。</p><p>此时依然通过了对象进行了类中的tell（）方法的调用，但是由于此对象没有任何的引用名称，所以此对象在使用一次后就将成为垃圾，而所有的垃圾将被GC进行回收与释放。</p><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC81NDI0MS8zMDcxMw=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
    <category term="java基础" scheme="https://www.liubai-icu.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>类与对象的定义及其使用</title>
    <link href="https://www.liubai-icu.top/2021/08/19/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.liubai-icu.top/2021/08/19/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/</id>
    <published>2021-08-18T16:00:00.000Z</published>
    <updated>2021-08-18T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h4 id="类与对象的定义"><a href="#类与对象的定义" class="headerlink" title="类与对象的定义"></a>类与对象的定义</h4><p>在Java中类是一个独立的结构体，所以需要使用class来进行定义，而在类中主要有属性和方法组成，属性就是一个个具体的变量，方法就是可以重复执行的代码。</p><p>范例：定义一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;<span class="comment">//定义一个类</span></span><br><span class="line">    String name;<span class="comment">//人员的姓名</span></span><br><span class="line">    <span class="keyword">int</span> age;<span class="comment">//人的年龄</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;、年龄：&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个类中定义有两个属性（name、age）和一个方法（tell（））。</p><p>现在有了类之后，如果要想使用类，那么就必须通过对象来完成，而如果要产生对象，那么必须使用如下的语法格式来完成：</p><ul><li>声明并实例化对象名称：<code>类名称 对象名称=new 类名称();</code></li><li>分步完成：<ul><li>声明对象：<code>类名称 对象名称=null;</code><ul><li>需要注意的是在声明变量对象等的时候要设置一个默认值，类的数据类型是引用类型，其默认值为null；</li></ul></li><li>实例化对象：<code>对象名称=new 类名称();</code></li></ul></li></ul><p>当获取了实例化对象之后，那么就需要通过对象进行类中的操作调用，此时有两种调用方式：</p><ul><li>调用类中的属性：<code>实例化对象.成员属性</code>;</li><li>调用类中的方法：<code>实例化对象.方法名称()</code>；</li></ul><p>范例：完整的使用过程，以上面的Person类为例   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;、年龄：&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        Person per=<span class="keyword">new</span> Person();</span><br><span class="line">        per.name=<span class="string">&quot;留白&quot;</span>;</span><br><span class="line">        per.age=<span class="number">19</span>;</span><br><span class="line">        per.tell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有进行对向属性内容所谓设置，则该数据内容为数据类型的默认值。</p><h4 id="对象实例化操作初步分析"><a href="#对象实例化操作初步分析" class="headerlink" title="对象实例化操作初步分析"></a>对象实例化操作初步分析</h4><p>Java中类属于引用数据类型，引用数据类型最大的困难之处在于要进行内存的管理，同时在进行操作的时候也会发生内存关系的变化，所以本次针对于上面的程序的内存关系进行一些简单的分析。</p><h5 id="对象内存分析"><a href="#对象内存分析" class="headerlink" title="对象内存分析"></a>对象内存分析</h5><p>最为常用的两块内存空间：</p><ul><li>堆内存：保存的是对象的具体信息，在程序之中堆内存空间的开辟是通过<code>new</code>完成的；（new拥有内存开辟的最高级别）</li><li>栈内存：保存的是一块堆内存的地址，即：通过地址找到堆内存，而后找到对象内容。</li></ul><p>由于之前学习过c语言，所以下面的分析会借助于c语言的概念理解其对象实例化的过程。</p><p>两中对象实例化的过程分析：</p><ul><li>声明并实例化对象：</li></ul><p><strong>Person per=new Person()；</strong>程序是从右向左执行的，所以我们也从从右向左分析；</p><p><strong>new</strong>方法类似于c语言里的<strong>malloc</strong>函数，功能都是申请一块空间，所以<strong>new</strong>的功能就知道了；但是申请多大的空间呢，于是有了后面这句话<strong>Person()<strong>，意思就是告诉电脑我要像</strong>Person</strong>那么大的空间，那么<strong>Person</strong>类里有什么，new申请的空间里就有什么，并按照Person类里的数据类型进行了数据的初始化，初始化数值就是设数据类型相对应的默认值，例如：引用数据类型的默认值即为null，整型的默认值为0；</p><p>然后来看等号左边的语句，<strong>Person per</strong>相当于声明了一个Person类型的变量，类似于c语言里的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tydef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125; *Person;</span><br><span class="line"></span><br><span class="line">Person per; </span><br></pre></td></tr></table></figure><p>没错，相当于申请了一个指针类型的变量，而指针类型的变量所存储的数据是一个地址。所以，**Person per=new Person();**的意思就是：申请了一块大小为Person的堆空间，并进行了数据的初始化操作，然后返回了这块空间的地址将其赋值给了per。即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tydef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125; *Person,person;</span><br><span class="line"></span><br><span class="line">Person per=Person <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(person)); </span><br></pre></td></tr></table></figure><ul><li>分步完成对象的实例化：<ul><li>声明对象；</li><li>实例化对象；</li></ul></li></ul><p>有了上面的理解，那第二种对象实例化方法就很好理解了，第一步就是先声明了一个引用类型的变量，并初始化其值为null；第二步就是new一个空间并把地址赋给per。</p><p>相当于下面的c与语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tydef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125; *Person,person;</span><br><span class="line"></span><br><span class="line">Person per;</span><br><span class="line">per=Person <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(person)); </span><br></pre></td></tr></table></figure><p><strong>总结</strong>：对象实例化的过程就是为对象开辟存储对象信息的空间，并得到这个空间的地址；声明对象后，一定要将对象实例化，否则该对象是不能操作的。</p><h4 id="对象引用分析"><a href="#对象引用分析" class="headerlink" title="对象引用分析"></a>对象引用分析</h4><h5 id="引用传递分析"><a href="#引用传递分析" class="headerlink" title="引用传递分析"></a>引用传递分析</h5><p>类本身属于引用数据类型，既然是引用数据类型，那么就牵扯到内存的引用传递，所谓的引用传递的本质：同一块堆内存可以被不同的栈内存所指向。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;、年龄：&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        Person per1=<span class="keyword">new</span> Person();</span><br><span class="line">        per1.name=<span class="string">&quot;留白&quot;</span>;</span><br><span class="line">        per1.age=<span class="number">19</span>;</span><br><span class="line">        Person per2=per1;<span class="comment">//引用传递</span></span><br><span class="line">        per2.age=<span class="number">21</span>;</span><br><span class="line">        per.tell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后的age等于21</span></span><br><span class="line"><span class="comment">//per1和per1指向的是同一块堆内存，即per1和per2内存的地址相同</span></span><br></pre></td></tr></table></figure><p>这个时候的引用传递是直接在主方法之中定义的，也可以通过方法实现引用传递。</p><p>范例：利用方法实现引用传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;、年龄：&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        Person per1=<span class="keyword">new</span> Person();</span><br><span class="line">        per.name=<span class="string">&quot;留白&quot;</span>;</span><br><span class="line">        per.age=<span class="number">19</span>;</span><br><span class="line">        per.tell();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Person temp)</span></span>&#123;</span><br><span class="line">        temp.age=<span class="number">21</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码传递的是地址，所以可以改变对象的值。</p><h5 id="引用传递与垃圾产生分析"><a href="#引用传递与垃圾产生分析" class="headerlink" title="引用传递与垃圾产生分析"></a>引用传递与垃圾产生分析</h5><p>经过上面的分析，引用传递的本质就是一场堆内存的调戏游戏。但是对于引用传递处理不当那么也会造成垃圾的产生，下面会对垃圾产生原因的简单分析。</p><p>范例“</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;、年龄：&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        Person per1=<span class="keyword">new</span> Person();</span><br><span class="line">        Person per2=<span class="keyword">new</span> Person();</span><br><span class="line">        per1.name=<span class="string">&quot;留白&quot;</span>;</span><br><span class="line">        per1.age=<span class="number">19</span>;</span><br><span class="line">        per2.name=<span class="string">&quot;小明&quot;</span>;</span><br><span class="line">        per2.age=<span class="number">20</span>;</span><br><span class="line">        per2=per1;<span class="comment">//引用传递，垃圾产生的原因</span></span><br><span class="line">        per2.age=<span class="number">21</span>;</span><br><span class="line">        per1.tell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来<code>per1</code>和<code>per2</code>都各自指向了一块堆内存，但是由于<code>per1=per2;</code>这句话，使得<code>per2</code>指向<code>per1</code>所指的空间，那么，<code>per2</code>所指的空间的没用栈内存指向它了，所以就变成了垃圾。</p><p>所谓的垃圾空间指的就是没有任何栈内存所致向的堆内存空间，所有的垃圾将被GC（Garbage Collector、垃圾收集器）不定期进行回收并且释放无用内存空间，但是如果垃圾过多，一定将影响到GC的处理性能，从而降低整体的程序性能，那么在实际的开放过程中，对于垃圾的产生越少越好。</p><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC81NDI0MS8zMDcxMw=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
    <category term="java基础" scheme="https://www.liubai-icu.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>面向对象及类和对像的简介</title>
    <link href="https://www.liubai-icu.top/2021/08/18/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B/"/>
    <id>https://www.liubai-icu.top/2021/08/18/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B/</id>
    <published>2021-08-17T16:00:00.000Z</published>
    <updated>2021-08-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p><strong>前言</strong>：要开始学习面向对象，之前听说，一直以为是模块化变成，类似于c语言里的结构体。今天来真实的了解一下。</p><p>​    最早并且一直流行到现在的编程语言C、C++、Java。其中C语言啊已经变为了面向过程编程的代表；而C++、Java是面向对象的编程语言。</p><p>所谓的面向过程指的是面对于一个问题的解决方案，更多的情况下是不会做出重用的设计思想的；而面向对象的主要事迹方式为模块化设计 ，并且可以进行重用配置。在整个的面向对象的设计里面更多情况下考虑的是标准，在使用的时候根据标准进行拼装。</p><h5 id="对于面向对象设计有三个主要特征："><a href="#对于面向对象设计有三个主要特征：" class="headerlink" title="对于面向对象设计有三个主要特征："></a>对于面向对象设计有三个主要特征：</h5><pre><code>- 封装性：内部的操作对外部而言不可见，当内部的操作都不可直接使用的时候才是安全的；- 继承性：在已有结构的基础上继续进行功能的扩充；- 多态性：是在继承性的基础上扩充而来的概念，指的是类型的转换处理；</code></pre><h5 id="在进行面向对象程序开发之中一般还有三个步骤："><a href="#在进行面向对象程序开发之中一般还有三个步骤：" class="headerlink" title="在进行面向对象程序开发之中一般还有三个步骤："></a>在进行面向对象程序开发之中一般还有三个步骤：</h5><pre><code>- OOA：面向对象分析；- OOD：面向对象设计；- OOP：面向对象编程；</code></pre><h4 id="类与对象的简介"><a href="#类与对象的简介" class="headerlink" title="类与对象的简介"></a>类与对象的简介</h4><p>面向对象是一个非常庞大的话题，其核心组成为：类和对象。</p><p>类是对某一事物的共性的抽象概念，而对象描述的是一个具体的产物。</p><p>类和对象的关系，可以用一个列子进行解释：我们都是人，但我们之间是不同的。我们都属于人这个群体，人就相当于一个类，但是我们之间是有不同属性的，例如：性别、年龄、姓名这些属性都是不尽相同的，所以每一个人就相当于一个对象。</p><p>自己的几个理解：</p><ul><li>类是一个模板，而对象才是类可以使用的实列，先有类再有对象。</li><li>类是一个标准，不能直接用，对象是可以直接用的。</li><li>对象是类的实列。</li></ul><p>在类中一般都会有两个组成：</p><ul><li>成员属性（Field）：简称为属性；<ul><li>一个人的年龄、姓名都是不同的，所以这些对于整体来讲就称为属性。</li></ul></li><li>操作方法（Method）：定义对象具有的处理行为；<ul><li>这个人可以唱歌、游泳等；</li></ul></li></ul><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC81NDI0MS8zMDcxMw=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
    <category term="java基础" scheme="https://www.liubai-icu.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java程序逻辑控制语句</title>
    <link href="https://www.liubai-icu.top/2021/08/16/Java%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
    <id>https://www.liubai-icu.top/2021/08/16/Java%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</id>
    <published>2021-08-15T16:00:00.000Z</published>
    <updated>2021-08-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>​    在程序开发的过程中一共会存在三种程序逻辑：顺序结构、分支结构和循环结构，之前所写的代码基本都是顺序结构。</p><h4 id="IF分支结构"><a href="#IF分支结构" class="headerlink" title="IF分支结构"></a>IF分支结构</h4><p>​        if分支结构主要针对关系表达式进行判断处理的分支操作。主要有三类使用形式，关键字主要是<code>if</code>和<code>else</code>。</p><ul><li>if</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">    条件满足时;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>if…else…</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">    条件满足时;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    条件不满足时;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多判断条件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">    条件满足时;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">    条件满足时;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">    条件满足时;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">[<span class="keyword">else</span>&#123;</span><br><span class="line">    条件不满足时;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h4 id="SWITCH开关语句（属于分支语句）"><a href="#SWITCH开关语句（属于分支语句）" class="headerlink" title="SWITCH开关语句（属于分支语句）"></a>SWITCH开关语句（属于分支语句）</h4><p>​    switch主要是根据内容来进行的判断，需要注意的是，它能够判断的只能是数据，并且数据类型只能是：int、char、枚举和String，而不能够使用逻辑判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(数据)&#123;</span><br><span class="line">        <span class="keyword">case</span> 数值：&#123;<span class="comment">//&#123;&#125;可以写也可以不写</span></span><br><span class="line">            数值满足时;</span><br><span class="line">            [<span class="keyword">break</span>;]<span class="comment">//可选项</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> 数值：&#123;</span><br><span class="line">            数值满足时;</span><br><span class="line">            [<span class="keyword">break</span>;]</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">default</span>:&#123;<span class="comment">//default也是可选项</span></span><br><span class="line">            所有判断数值不满足时;</span><br><span class="line">            [<span class="keyword">break</span>;]</span><br><span class="line">        &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意：break；这句不加的话，当数据满足第一个case语句的数值的时候，之后 的语句将不进行判断，直接执行。</p><p>从JDK1.7的时代开始，Oracle公司推出的JDK1.7版本里面将开发着呼吁10年以上的功能加到了系统之中，可以进行字符串数据的判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        String str=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span>(str)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Hello&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;NO match&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果为 hello</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="WHILE循环语句"><a href="#WHILE循环语句" class="headerlink" title="WHILE循环语句"></a>WHILE循环语句</h4><p>​    所谓的循环结构就是某一段代码被重复执行。</p><ul><li>while()循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(布尔表达式)&#123;</span><br><span class="line">    条件满足时执行;</span><br><span class="line">    修改循环条件;    <span class="comment">//不修改的话就会变成死循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>do…while()循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    条件满足时执行;</span><br><span class="line">    修改循环条件;    <span class="comment">//不修改的话就会变成死循环</span></span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式);</span><br></pre></td></tr></table></figure><ul><li><p>while与do…while的区别</p><ul><li><p>前者是先进行判断在执行，后者是先执行一次再进行判断。</p></li><li><p>后者使用机率非常小，几乎只有1%。</p></li></ul></li></ul><h4 id="FOR循环语句"><a href="#FOR循环语句" class="headerlink" title="FOR循环语句"></a>FOR循环语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(定义循环的初始化数值;循环判断;修改循环数据)&#123;</span><br><span class="line">    循环语句的执行;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>范例：实现从1到100的累加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=<span class="number">100</span>;x++)&#123;</span><br><span class="line">    sum+=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>与C语言一样，for里面的三项参数甚至都可以省略，但```;``是不能少的。（这是不建议的）</li><li>while和for循环的一般选择参考<ul><li>在明确确定循环次数的情况下优先选择for循环；</li><li>在不知道循环次数但是知道循环结束条件的情况下使用while循环；</li></ul></li></ul><h4 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h4><p>​    在循环语句定义的时候还有两个控制语句：break、continue；（与c语言的功能一样）。</p><ul><li>break的功能是退出整个循环结构；</li><li>continue的功能是退出本次（当前）循环，不执行continue之后的语句直接开始下一次循环；</li><li>continue有个功能可以实现C语言里的goto的部分功能，但不建议使用，容易造成代码的混乱。（小编现知道这样用）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        point: <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;<span class="number">10</span>;x++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">3</span>)</span><br><span class="line">                <span class="keyword">continue</span> point;</span><br><span class="line">            System.out.print(x+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果:0 1 2 4 5 6 7 8 9 </span></span><br><span class="line"><span class="comment">//少了3</span></span><br></pre></td></tr></table></figure><h4 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h4><p>​    简单来说就是循环套循环，但嵌套的越多，时间复杂度也就越高。</p><p>下面用打印乘法表来进行演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=<span class="number">9</span>;x++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">1</span>;y&lt;=x;y++)&#123;</span><br><span class="line">                System.out.print(y+<span class="string">&quot;x&quot;</span>+x+<span class="string">&quot;=&quot;</span>+x*y+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1x1=<span class="number">1</span> </span><br><span class="line">1x2=<span class="number">2</span> 2x2=<span class="number">4</span> </span><br><span class="line">1x3=<span class="number">3</span> 2x3=<span class="number">6</span> 3x3=<span class="number">9</span> </span><br><span class="line">1x4=<span class="number">4</span> 2x4=<span class="number">8</span> 3x4=<span class="number">12</span> 4x4=<span class="number">16</span> </span><br><span class="line">1x5=<span class="number">5</span> 2x5=<span class="number">10</span> 3x5=<span class="number">15</span> 4x5=<span class="number">20</span> 5x5=<span class="number">25</span> </span><br><span class="line">1x6=<span class="number">6</span> 2x6=<span class="number">12</span> 3x6=<span class="number">18</span> 4x6=<span class="number">24</span> 5x6=<span class="number">30</span> 6x6=<span class="number">36</span> </span><br><span class="line">1x7=<span class="number">7</span> 2x7=<span class="number">14</span> 3x7=<span class="number">21</span> 4x7=<span class="number">28</span> 5x7=<span class="number">35</span> 6x7=<span class="number">42</span> 7x7=<span class="number">49</span> </span><br><span class="line">1x8=<span class="number">8</span> 2x8=<span class="number">16</span> 3x8=<span class="number">24</span> 4x8=<span class="number">32</span> 5x8=<span class="number">40</span> 6x8=<span class="number">48</span> 7x8=<span class="number">56</span> 8x8=<span class="number">64</span> </span><br><span class="line">1x9=<span class="number">9</span> 2x9=<span class="number">18</span> 3x9=<span class="number">27</span> 4x9=<span class="number">36</span> 5x9=<span class="number">45</span> 6x9=<span class="number">54</span> 7x9=<span class="number">63</span> 8x9=<span class="number">72</span> 9x9=<span class="number">81</span> </span><br></pre></td></tr></table></figure><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC81NDI0MS8zMDcxMw=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
    <category term="java基础" scheme="https://www.liubai-icu.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>方法的定义与使用</title>
    <link href="https://www.liubai-icu.top/2021/08/16/%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.liubai-icu.top/2021/08/16/%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2021-08-15T16:00:00.000Z</published>
    <updated>2021-08-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h3 id="方法的定义及使用"><a href="#方法的定义及使用" class="headerlink" title="方法的定义及使用"></a>方法的定义及使用</h3><p>​    方法（method）即为函数（function），两者的概念一样。</p><h4 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h4><p>基本定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名称([参数类型 变量,...])&#123;</span><br><span class="line">    <span class="comment">//该方法要执行的代码</span></span><br><span class="line">    [<span class="keyword">return</span>[返回值];]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>return返回的数据类型与方法声明的返回值类型相同；</li><li>返回值可以使用Java中定义的数据类型（基本数据类型、引用数据类型）；</li><li>无返回值的话方法使用的反回值类型为void；</li></ul><p>关于方法名称与变量的定义命名要求（不是硬性规定，只是一定的约定性建议：驼峰命名法）：</p><ul><li>在进行方法名称定义的时候要求第一个单词的字母小写，而后每个单词的首字母大写；</li><li>在进行变量名称的定义的时候要求与方法名称一样；</li></ul><p>一个无参无返回值的方法范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        printName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;留白!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        方法的本质是方便使用者进行重复的调用，并且所有的程序一定都是通过主方法开始执行的。</p><p>下面是一个有返回值有参数的方法范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> money=<span class="number">30</span>;</span><br><span class="line">        String result=get(money);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        System.out.println(get(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">(<span class="keyword">double</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(money&gt;=<span class="number">19.8</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;给你一份快餐，找你&quot;</span>+(money-<span class="number">19.8</span>)+<span class="string">&quot;元&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;余额不足！！！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果方法的返回值类型为void，那么可以利用return来结束方法的调用。</li></ul><h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><p>​    当方法名称相同，参数的类型或个数不同的时候就称为方法重载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> resultA=sum(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">int</span> resultB=sum(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">        <span class="keyword">double</span> resultC=sum(<span class="number">10.1</span>,<span class="number">20.4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;加法计算结果为:&quot;</span>+resultA);</span><br><span class="line">        System.out.println(<span class="string">&quot;加法计算结果为:&quot;</span>+resultB);</span><br><span class="line">        System.out.println(<span class="string">&quot;加法计算结果为:&quot;</span>+resultC);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> x + y + z;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">加法计算结果为:<span class="number">30</span></span><br><span class="line">加法计算结果为:<span class="number">60</span></span><br><span class="line">加法计算结果为:<span class="number">30.5</span></span><br></pre></td></tr></table></figure><p>​    从上面的列子可以看出同一个方法名称可以根据调用时传递的不同参数类型或个数实现不同方法体的调用，这样就实现了方法的重载。</p><p>​    千万要注意的一点时方法的重载与方法的返回值类型没有任何关系，它只跟参数有关系，但是在实际的开发过程中，一个基本原则是：只要是方法重载，强烈建议其返回值的类型相同。</p><h4 id="方法的递归调用"><a href="#方法的递归调用" class="headerlink" title="方法的递归调用"></a>方法的递归调用</h4><p>​    方法的递归调用指的是一个方法自己调用自己的情况，利用递归调用可以解决一些重复且麻烦的问题。在进行递归调用方法的时候，有下面的几点问题需要考虑：</p><ul><li>一定要设置方法调用的结束条件；</li><li>每次调用的过程之中一定要修改传递的参数条件；</li></ul><p>下面使用从1到100的累加和演示递归的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        System.out.println(sum(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">1</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> num+sum(num-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程分析：</p><p>第一次执行sum（100）：return 100+sum(99);</p><p>第二次执行sum  (99)：return 99+sum（98）；</p><p>…</p><p>第99次执行sum（2）：return 2+sum（1）；</p><p>第100次执行sum（1）：num==1,return 1;</p><p>整体：return 100+99+…+2+1；</p><p>递归调用还需要注意的另一个问题是内存溢出问题，很多很多次的递归的话就会发生内存溢出的情况。</p><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC81NDI0MS8zMDcxMw=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
    <category term="java基础" scheme="https://www.liubai-icu.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java的运算符</title>
    <link href="https://www.liubai-icu.top/2021/08/08/Java%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://www.liubai-icu.top/2021/08/08/Java%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2021-08-07T16:00:00.000Z</published>
    <updated>2021-08-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h4 id="运算符简介"><a href="#运算符简介" class="headerlink" title="运算符简介"></a>运算符简介</h4><p>​    程序开发实际上就是一种数据操作游戏，所以每种语言都提供了大量的基础运算用于各种操作，比如加减乘<code>+、-、*、/</code>，需要注意的是，各种运算夫之间的优先级。</p><hr><ul><li><p>数学运算符</p><ul><li>主要说明的是自增和自减操作（与C语言一样）<ul><li>当++和–做前缀的时候，先计算++和–；</li><li>当做后缀的时候，先使用变量再进行自增自减；</li></ul></li><li><code>++、--、/=、+=、*=、%=</code>等这些操作都是当时减少内存开销的手段；</li></ul></li><li><p>关系运算符</p><ul><li><p>与c语言不通的是，关系运算会返回Boolean类型的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> y=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag=x==y;</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果位true</span></span><br></pre></td></tr></table></figure></li><li><p>另一个让我感到惊艳的是，在Java中字符串也可以直接进行比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        String str1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String str2=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag=str1==str2;</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果为 true</span></span><br></pre></td></tr></table></figure><p>还有就是，由于采用uicode编码，汉字字符也可以进行比较。</p></li></ul></li><li><p>逻辑运算符</p><ul><li><p>讲解一个三目运算符</p><ul><li><p><code>？：</code>：关系运算？关系满足：关系不满足；</p></li><li><p>三目运算的优点是可以减少运算量</p></li><li><p>经典列子：（两个数求其中的最大值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">10</span>,y=<span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> max=x&gt;y?x:y;</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>三目运算符也可以进行嵌套的，但是可读性降低，一般不建议使用。比如下面的例子（求三个数中的最大值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">10</span>,y=<span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> z=<span class="number">30</span>;</span><br><span class="line">        <span class="keyword">int</span> max=(x&gt;y)?(x&gt;z?x:z):(y&gt;z?y:z);</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>位运算</p><p>位运算指的是可以直接进行二进制数据的计算处理。</p><ul><li>与运算（&amp;）<ul><li>对应位都为1的时候才为1，否则为0</li></ul></li><li>或运算（|）<ul><li>对应位中只要有一位是1，则结果为1，两位都为0的时候结果才为0</li></ul></li><li>异或运算（^）<ul><li>对应位值相同为1，否则为0</li></ul></li><li>反码（~）<ul><li>是一元运算符，将0变1，1变0</li></ul></li><li>位移操作<ul><li>&lt;&lt;（左移）用来将一个数的各二进制位全部左移N位，右补零</li><li><code>&gt;&gt;</code>（右移）将一个数的各二进制位右移N位，移动到右端的位被舍弃，对于无符号数高位补零</li></ul></li></ul></li></ul><hr><p>关于位操作的一些使用技巧和“歪门邪道”，之后会更新整理。。。（2021-08-09）</p><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC81NDI0MS8zMDcxMw=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
    <category term="java基础" scheme="https://www.liubai-icu.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>对Java数据类型的简单认识</title>
    <link href="https://www.liubai-icu.top/2021/08/07/Java%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://www.liubai-icu.top/2021/08/07/Java%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-08-06T16:00:00.000Z</published>
    <updated>2021-08-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h4 id="Java数据类型简介"><a href="#Java数据类型简介" class="headerlink" title="Java数据类型简介"></a>Java数据类型简介</h4><ul><li><p>程序的最终目的是对数据进行处理，所以就一定需要各种数据类型的定义</p></li><li><p>Java数据分类</p><p>在Java语言中，对数据类型一共分为两类：</p><ul><li>基本数据类型：描述的是一些具体的数字单元。<ul><li>数值型：<ul><li>整形：<code> byte</code>、<code>short</code>、<code>int</code>、<code>long</code>；            →默认值：0；</li><li>浮点型：<code>float</code>、<code>double</code>；                             →默认值：0.0；</li></ul></li><li>布尔型：<code>boolean</code>；                                                  →默认值：false；</li><li>字符型：<code>char</code>；                                                        →默认值：’\u0000’;</li></ul></li><li>引用数据类型：牵扯到内存关系的使用（较复杂）<ul><li>数组、类、接口。                                                      →默认值：null;</li></ul></li></ul></li><li><p>一些数据类型上的选择（仅供参考）</p><ul><li>如果要是描述数字首选的一定是int（整数）、double（小数）；</li><li>如果是要进行数据传输或者是进行文字编码转换使用byte类型（二进制处理操作）；</li><li>处理中文的时候最方便的操作使用的是字符char来完成（可选概念）；</li><li>描述内存或文件大小、描述表的主键列（自动增长类）可以使用long；</li></ul></li></ul><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul><li><p>整型数据类型（按照保存的范围由小到大：byte、short、int、long）</p><p>整数类数字默认的都为int型；</p><ul><li>byte<ul><li>大小：8位</li><li>范围：-128~127</li></ul></li><li>short<ul><li>大小：16位</li><li>范围：-32768~32767</li></ul></li><li>int<ul><li>大小：32位</li><li>范围：-2147483648~2147483647</li></ul></li><li>long<ul><li>大小：64位</li><li>范围：-9223372036854775808 ~ 9223372036854775807（-2E64~2E64-1）</li></ul></li><li>关于数据溢出<ul><li>数据溢出是指变量所存储的数据超过了该变量数据类型的存储范围</li><li>当发生数据溢出的时候就要进行数据类型的转换<ul><li>强制数据类型的转换<code>（要转换的数据类型）变量名</code>;</li><li>不建议范围大的数据类型向范围小的数据类型转换，会损失精度;</li><li>在不同类型数据类型进行计算的时候程序一般会趋于向更大范围的数据类型转换;</li></ul></li></ul></li></ul></li><li><p>浮点型数据类型</p><p>小数类数字默认的都是double类型；要想使用float类型的数据，只要在赋值的时候在后面加上F即可。但是要注意数据精度的要求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">float</span> x=<span class="number">10.1F</span>;</span><br><span class="line">        <span class="keyword">double</span> y=<span class="number">10.1</span>;</span><br><span class="line">        System.out.println(x*x);</span><br><span class="line">        System.out.println(y*y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">102.01001</span></span><br><span class="line"><span class="number">102.00999999999999</span></span><br></pre></td></tr></table></figure><ul><li>float（单精度）<ul><li>大小：32位</li><li>范围：-3.4E38~3.4E38</li></ul></li><li>double（双精度）<ul><li>大小：64</li><li>范围：-1.7E308~1.7E308</li></ul></li></ul></li><li><p>字符型数据</p><p>char适合保存中文数据，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c=<span class="string">&#x27;仁&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> num=c;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//20161</span></span><br></pre></td></tr></table></figure><p>之所以可以这样，是因为java使用的是unicode这种十六进制的编码，这种编码的特点是可以包括任意的文字内容。</p><ul><li>char<ul><li>大小：16位</li><li>范围：0~65536</li></ul></li></ul></li><li><p>布尔数据类型</p><p>布尔是一位数学家的名字，布尔主要描述的是一种逻辑的处理结果。</p><ul><li>boolean<ul><li>只有两个值：true、false；</li><li>值得注意的是，在不存在boolean类型的编程语言中（比如c语言），会使用0表示false，非零数表示true，但在java中是不存在这种情况的。</li></ul></li></ul></li><li><p>String字符串</p><ul><li>在任何语言里都没有提供所谓的字符串这种基本数据类型，但是从实际的应用上来看也都会提供有字符串的相应描述，在Java里面使用的是String作为字符串的定义。</li><li>由于String类的存在较为特殊，所以其可以向普通变量那样采用直接复制的方式进行赋值，但值的内容是需要在<code>&quot;&quot;</code>（英文）里的。</li><li>注意：<ul><li>在Java中<code>+</code>可以用于字符串的连接，当数据计算时有String类型的时候，数据会无条件的转向String类型，所以要加<code>（）</code>提高其他运算符的等级；</li><li>转义字符的使用，与C语言一样。</li></ul></li></ul></li></ul><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC81NDI0MS8zMDcxMw=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
    <category term="Java基础" scheme="https://www.liubai-icu.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>PASH和CLASSPATH的设置和初步理解</title>
    <link href="https://www.liubai-icu.top/2021/08/06/PASH%E5%92%8CCLASSPATH%E5%B1%9E%E6%80%A7%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.liubai-icu.top/2021/08/06/PASH%E5%92%8CCLASSPATH%E5%B1%9E%E6%80%A7%E7%9A%84%E9%85%8D%E7%BD%AE/</id>
    <published>2021-08-05T16:00:00.000Z</published>
    <updated>2021-08-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><ul><li><h4 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h4><ul><li>为什么要配置Path环境变量？<ul><li>什么是Path环境变量？<br><strong>PATH是操作系统提供的路径配置，定义所有可执行程序的路径。</strong></li><li>在JDK里所有的可执行程序的路径为<code>D:\JDK\bin</code>(自己安装JDK的路径)，主要使用bin下的java.exe和javac.exe两个命令，即<code>java</code>和<code>javac</code>。但是这两个命令并不属于Windows本身，为了能够在命令行中使用这两个命令，所以才需要去配置Path这个环境变量。（注意是Path是系统环境变量下配置的）</li></ul></li><li>配置方法或者格式<ul><li>环境变量的寻找路径：<code>【此电脑】→【属性】→【高级系统设置】→【环境变量】→【系统变量】→【Path】→【编辑】</code></li><li>在Path变量下添加一个<code>D:\JAVA\SOFT\JDK\jdk16\bin</code>（自己JDK的安装路径）</li></ul></li></ul></li><li><h4 id="CLASSPATH"><a href="#CLASSPATH" class="headerlink" title="CLASSPATH"></a>CLASSPATH</h4><ul><li><p>为什么要配置CLASSPATH环境变量？</p><ul><li><p>什么是CLASSPATH变量？</p><p>​    <strong>CLASSPATH是JRE提供的，用于定义Java程序解释时类加载路径，默认设置的为当前所在目录加载。</strong></p></li><li><p>JVM会先找到CLASSPATH定义的路径然后再加载字节码文件。</p><ul><li>存在关系：<strong>JVM→CLASSPATH定义的路径→加载字节码文件。</strong></li></ul></li><li><p>虽然会默认为当前路径加载，即<code>.</code>,但是当安装其他Java软件是，有可能被更改，形成加载混乱，所以有必要重新设置一下。</p></li></ul></li><li><p>配置方法</p><ul><li>如同Path一样在系统变量里设置，但CLASSPATH变量需要自己去添加。<ul><li>其值为：<code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</code> (其中<code>.</code>是必须要有的)</li><li>%JAVA_HOME%的解释<ul><li>JAVA_HOME是一个常用的变量，其中<code>JAVA_HOME的值</code>为JDK的安装路径<code>D:\JAVA\SOFT\JDK\jdk16</code>,这样的话Path需要添加的即为<code>%JAVA_HOME%\bin</code></li></ul></li></ul></li></ul></li></ul></li></ul><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC81NDI0MS8zMDcxMw=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>快速幂</title>
    <link href="https://www.liubai-icu.top/2021/08/02/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>https://www.liubai-icu.top/2021/08/02/%E5%BF%AB%E9%80%9F%E5%B9%82/</id>
    <published>2021-08-01T16:00:00.000Z</published>
    <updated>2021-08-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h4 id="快速幂-Fast-Power"><a href="#快速幂-Fast-Power" class="headerlink" title="快速幂(Fast_Power)"></a>快速幂(Fast_Power)</h4><p>​        当要计算a^b的结果时，一般想到的方法就是循环b次a*a</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Normal_Power</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> base,<span class="keyword">long</span> <span class="keyword">long</span> power)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> result=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;power;i++)&#123;</span><br><span class="line">        result*=base;l</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        虽然现在电脑的运算速度都已经非常快了，但是当遇到2^1000000000这种情况，怎么也要几秒吧？这种耗时的计算肯定不可取的。（想必总不能看着OJ里的超时提醒，你不……）</p><p>​        快速幂其实很简单，运算方法你一定见过，还记得高中数学的一个式子吧<code>2^4=(2^2)^2=4^2</code>，于是有了下面的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Fast_power</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> base,<span class="keyword">long</span> <span class="keyword">long</span> power)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> result=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(power&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(power%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            base*=base;</span><br><span class="line">            power/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            power--;</span><br><span class="line">            result*=base;</span><br><span class="line">            power/=<span class="number">2</span>;</span><br><span class="line">            base*=base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速幂优化"><a href="#快速幂优化" class="headerlink" title="快速幂优化"></a>快速幂优化</h4><ul><li>第一次优化（由于上面的代码，if和else部分还是有重复部分的）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">power/=<span class="number">2</span>;</span><br><span class="line">base*=base;</span><br></pre></td></tr></table></figure><p>​        将其精简后变成下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Fast_power</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> base,<span class="keyword">long</span> <span class="keyword">long</span> power)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> result=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(power&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(power%<span class="number">2</span>==<span class="number">1</span>) result*=base;</span><br><span class="line">        power/=<span class="number">2</span>;</span><br><span class="line">        base*=base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>通过c语言的位运算压榨最后的性能</p><p>（如果power为偶数，则表示其的二进制的最后一位一定是0；否则为1。power的二进制向右移动一位则值为其原来的一半）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Fast_power</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> base,<span class="keyword">long</span> <span class="keyword">long</span> power)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> result=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(power&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(power&amp;<span class="number">1</span>) result*=base;</span><br><span class="line">        power&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        base*=base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_19782019/article/details/85621386?ops_request_misc=%7B%22request_id%22:%22162786442116780357269498%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=162786442116780357269498&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-85621386.first_rank_v2_pc_rank_v29&utm_term=%E5%BF%AB%E9%80%9F%E5%B9%82&spm=1018.2226.3001.4187">参考文章</a></p></li></ul><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC81NDI0MS8zMDcxMw=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
    <category term="算法" scheme="https://www.liubai-icu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>利用IP映射加速GitHub的访问</title>
    <link href="https://www.liubai-icu.top/2021/07/29/2021-7-29-%E5%88%A9%E7%94%A8IP%E6%98%A0%E5%B0%84%E5%8A%A0%E9%80%9FGitHub%E7%9A%84%E8%AE%BF%E9%97%AE/"/>
    <id>https://www.liubai-icu.top/2021/07/29/2021-7-29-%E5%88%A9%E7%94%A8IP%E6%98%A0%E5%B0%84%E5%8A%A0%E9%80%9FGitHub%E7%9A%84%E8%AE%BF%E9%97%AE/</id>
    <published>2021-07-28T16:00:00.000Z</published>
    <updated>2021-09-24T08:32:15.360Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于刚重装完系统，之前的配置都已经没了。忘了如何配置的我又不得不去找教程，这次一我自己把这个过程记录下来，以便之后使用</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h5 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h5><p>通过查询域名的IP，配置hosts实现加速github的效果。（由于映射的IP有时会变化，所以变的时候要去重新查询和配置）</p><h5 id="下面是两个查询IP的网站（建议先使用第一个）"><a href="#下面是两个查询IP的网站（建议先使用第一个）" class="headerlink" title="下面是两个查询IP的网站（建议先使用第一个）"></a>下面是两个查询IP的网站（建议先使用第一个）</h5><ul><li><a href="https://markdown.com.cn/basic-syntax/links.html">IPAddress.com</a></li><li><a href="http://tool.chinaz.com/dns/">站长工具</a></li></ul><h5 id="需要查询的网址"><a href="#需要查询的网址" class="headerlink" title="需要查询的网址"></a>需要查询的网址</h5><ul><li>github.com</li><li>assets-cdn.github.com</li><li>github.global.ssl.fastly.net</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol><li><p>查询以上网址的IP地址，并记录下来（出现一个域名多个IP的，把所有IP都记录下来）</p></li><li><p>找到hosts文件的地址（C:\Windows\System32\drivers\etc）</p></li><li><p>将记录的东西添加到hosts文件中<img src="https://startdreamman.github.io/LDK/img/hosts_github.png" alt="hosts示例图"></p></li><li><p>刷新本机的DNS解析缓存</p><ol><li>win+R，打开cmd</li><li>输入命令ipconfig/flushdns</li></ol></li><li><p>测试</p></li></ol><p><a href="https://blog.csdn.net/weixin_45604606/article/details/116399620">文章参考源地址</a></p><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC81NDI0MS8zMDcxMw=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello,my blog world</title>
    <link href="https://www.liubai-icu.top/2021/07/25/Hello_World/"/>
    <id>https://www.liubai-icu.top/2021/07/25/Hello_World/</id>
    <published>2021-07-25T14:37:00.000Z</published>
    <updated>2021-07-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><hr><h3 id="纪念我的第一篇博客"><a href="#纪念我的第一篇博客" class="headerlink" title="纪念我的第一篇博客"></a>纪念我的第一篇博客</h3><ul><li>每学一种语言的开始都是先学会写<strong>Hello World!</strong>,  还记得当我第一次用<strong>C</strong>语言敲下这串代码时的激动与喜悦，在之后用<strong>JAVA</strong>和<strong>Python</strong>敲出时也仍是抱着一样的心情。</li><li>每一种语言都是一个新颖的世界，这个属于我的博客网站也一样，所以我的第一篇博客的名字诞生： <strong>Hello,my blog world!</strong></li><li>关于<strong>赞美愚者</strong>，来自<strong>《诡秘之主》</strong>这本小说，它给我的感觉就像一个全新奇幻而又真实的世界。<strong>切记</strong>：不要直视神，就算是愚者，也不要直视祂！！！哦，赞美愚者！！！</li></ul><h3 id="网站历程"><a href="#网站历程" class="headerlink" title="网站历程"></a>网站历程</h3><ul><li><p>怎么说呢？改用一句名言：<strong>BugBug ErrorError FailedFailed,怎一个苦字了得</strong></p></li><li><p>回家后玩了一天，一直到现在。只要是醒着，不是在吃饭，就一定在电脑前坐着，弄得现在脖子和背都很酸痛。各种不知名的报错加上电脑的问题（忍它蓝屏好久了），不过解决后也很开心。</p></li><li><p>主要在搞<strong>音乐播放</strong>功能，<strong>聊天室</strong>的建立，还有<strong>评论功能</strong>的加入</p></li><li><p>一些页面还没有开始建立，以后会<strong>佛系更新</strong>的，。</p></li><li><p>特别鸣谢：我的好<strong>巨人</strong>，他网站的链接在这里**<a href="https://dengxiayouhun.github.io/">青春玩命的年代</a>**,<strong>已经有好多篇博文了哦，快去盘他！！！</strong></p><h3 id="音乐链接"><a href="#音乐链接" class="headerlink" title="音乐链接"></a><strong><a href="https://startdreamman.github.io/LDK/music/">音乐链接</a></strong></h3></li></ul><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC81NDI0MS8zMDcxMw=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
  </entry>
  
</feed>
